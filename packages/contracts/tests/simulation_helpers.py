from brownie import *
import random
import numpy as np
from bisect import bisect_left

from helpers import *

#global variables
day = 24
month = 24 * 30
year = 24 * 365
period = year

#number of runs in simulation
#n_sim = 8640
n_sim = year

# number of liquidations for each call to `liquidateTroves`
NUM_LIQUIDATIONS = 10

MIN_NET_DEBT = 1950.0

"""# Ether price (exogenous)

Ether is the collateral for LUSD. The ether price $P_t^e$ follows 
> $P_t^e = P_{t-1}^e (1+\zeta_t^e)(1+\sigma_t^e)$, 

where $\zeta_t^e \sim N(0, $ sd_ether$)$ represents ether price shock and $\sigma_t^e$ the drift of ether price. At the end of the year, the expected ether price is:
> $E(P_{8760}^e) = P_0^e \cdot (1 +$ drift_ether$)^{8760}$

"""

#ether price
price_ether_initial = 1000
price_ether = [price_ether_initial]
sd_ether=0.02
drift_ether = 0


"""# Liquidity Pool

The demand of tokens from liquidity pool is defined by
> $$D_t^l = D_{t-1}^l (1+\zeta_t^l) (1+\sigma_t^l) (\frac{P_t^l}{P_{t-1}^l})^\delta, \\
D_0^l = liquidity\_initial$$

where $\zeta_t^l \sim N(0, sd\_liquidity)$ is the shock in the liquidity pool, $1+\sigma_t^l = drift\_liquidity$ and $\delta \leq -1$.
"""
# liquidity pool
liquidity_initial=0
sd_liquidity=0.001
drift_liquidity=1.0003
delta = -20

"""# Stability Pool

The demand of tokens from stability pool is defined by 
>$$D_t^s = D_{t-1}^s (1+\zeta_t^s) (1+R_{t-1}^s-R_{t}^n)^\theta, \\
D_0^s = stability\_initial$$

where $\zeta_t^s \sim N(0, sd\_stability)$ is the shock in the liquidity pool. 

During the first month the formula above is also multiplied by a drift factor, $drift\_stability$.

$R_{t-1}^s$ is the return in the stability pool, which consists of liquidation gain and airdrop LQTY gain.


The natural rate of the stability pool follows
> $$R_{t}^n=R_{t-1}^n(1+\zeta_t^n)\geq 0,$$

where $\zeta_t^n \sim N(0, sd\_return)$ is the natural rate shock and $R_{0}^n = natural\_rate\_initial$.

The natural rate compensates the opportunity cost and risk undertaken by the stability pool providers. It resembles the risk-free government bond return in the macroeconomics model. Stability pool depositors compare the return of the stability pool with the outside investment opportunities. A positive shock $\zeta_t^n$ implies investment on other platforms, e.g. Compound, Uniswap, Aave, yield higher returns, thus making the stability pool less appealing.

"""

#stability pool
initial_return = 0.2
sd_return = 0.001
stability_initial = 1000
sd_stability = 0.001
drift_stability = 1.002
theta = 0.001

#natural rate
natural_rate_initial = 0.2
natural_rate = [natural_rate_initial]
sd_natural_rate = 0.002

"""# Trove pool

Each trove is defined by five numbers
> (collateral in ether, debt in LUSD, collateral ratio target, rational inattention, collateral ratio)

which can be denoted by
> ($Q_t^e(i)$, $Q_t^d(i)$, $CR^*(i)$, $\tau(i)$, $CR_t(i)$).

**Open Troves**

The amount of new troves opened in period t is denoted by $N_t^o$, which follows 


> $N_t^o = \begin{cases} 
initial\_open &\mbox{if } t = 0\\
max(0, n\_steady \cdot (1+\zeta_t^o)) &\mbox{if } P_{t-1}^l \leq 1 + f_t^i\\
max(0, n\_steady \cdot (1+\zeta_t^o)) + \alpha (P_{t-1}^l - (1 + f_t^i)) N_t &\mbox{otherwise }
\end{cases}
$

where the shock $\zeta_t^o \sim N(0,sd\_opentroves)$. 

$R_t^o$ represents the break-even natural rate of opening troves and $f_t^i$ represents the issuance fee.

$P_{t}^{l}$ is the price of LUSD.

$N_t^o$ is rounded to an integer.

---

The amount of LUSD tokens generated by a new trove is
> $$Q_t^d(i) = \frac{P_t^e Q_t^e(i)}{CR^*(i)}.$$

---


The distribution of ether $Q_t^e(i)$ follows
> $Q_t^e(i) \sim \Gamma(k, \theta)$

So that $E(Q_t^e) = collateral\_gamma\_k \cdot collateral\_gamma\_theta$ and $Var(Q_t^e) = \sqrt{collateral\_gamma\_k} \cdot collateral\_gamma\_theta$

---


$CR^*(i)$ follows a chi-squared distribution with $df=target\_cr\_chi\_square\_df$, i.e. $CR^*(i) \sim \chi_{df}^2$, so that $CR^*(i)\geq target\_cr\_a$:
> $CR^*(i) = target\_cr\_a + target\_cr\_b \cdot \chi_{df}^2$. 

Then:\
$E(CR^*(i)) = target\_cr\_a + target\_cr\_b * target\_cr\_chi\_square\_df$, \\
$SD(CR^*(i))=target\_cr\_b*\sqrt{2*target\_cr\_chi\_square\_df}$



---
Each trove is associated with a rational inattention parameter $\tau(i)$.

The collateral ratio of the existing troves vary with the ether price $P_t^e$
> $$CR_t(i) = \frac{P_t^e Q_t^e(i)}{Q_t^d(i)}.$$

If the collateral ratio falls in the range 
> $CR_t(i) \in [CR^*(i)-\tau(i), CR^*(i)+2\tau(i)]$,

no action taken. Otherwise, the trove owner readjusts the collateral ratio so that
>  $CR_t(i)=CR^*(i)$.

The distribution of $\tau(i)$ follows gamma distribution $\Gamma(k,\theta)$ with mean of $k\theta$ and standard error of $\sqrt{k\theta^2}$.
"""

#open troves
initial_open=10
sd_opentroves=0.5
n_steady=0.5

collateral_gamma_k = 10
collateral_gamma_theta = 500

target_cr_a = 1.1
target_cr_b = 0.03
target_cr_chi_square_df = 16

rational_inattention_gamma_k = 4
rational_inattention_gamma_theta = 0.08

#sensitivity to LUSD price & issuance fee
alpha = 0.3

"""**Close Troves**

The amount of troves closed in period t is denoted as $N_t^c$, which follows
> $$N_t^c = \begin{cases} 
U(0, 1) &\mbox{if } t \in [0,240] \\ 
max(0, n\_steady \cdot (1+\zeta_t^c)) &\mbox{if } P_{t-1}^l \geq 1 \\ 
max(0, n\_steady \cdot (1+\zeta_t^c)) + \beta(1 - P_{t-1}^l)N_t &\mbox{otherwise }
\end{cases} $$

where the shock $\zeta_t^c \sim N(0, sd\_closetroves)$. 
$N_t^c$ is rounded to an integer.
"""

#close troves
sd_closetroves=0.5
#sensitivity to LUSD price
beta = 0.2

"""**Trove Liquidation**

At the beginning of each period, 
right after the feed of ether price, 
the system checks the collateral ratio of the exisitng troves in the
trove pool. 

If the collateral ratio falls below 110%, i.e.
> $$CR_t(i) = \frac{P_t^e Q_t^e(i)}{Q_t^d(i)}<110\%,$$

this trove is liquidated. Namely, it is eliminated from the trove pool.

Denote the amount of liquidated troves by $N_t^l$. The sum of the debt amounts to
> $$Q_t^d=\sum_i^{N_t^l} Q_t^d(i)$$

The amount of ether is
> $$Q_t^e=\sum_i^{N_t^l} Q_t^e(i)$$

The debt $Q_t^d$ is paid by the stability pool in exchange for the collateral $Q_t^e$. Therefore, the return of the previous period's stability pool is


> $$R_{t-1}^s=\frac{R_t^l+R_t^a}{P_{t-1}^lD_{t-1}^s}$$

where:
- $R_t^l=P_t^eQ_t^e-P_{t-1}^lQ_t^d$ is the liquidation gain 
- $R_t^a=P_{t}^q\hat{Q}_t^q$ is the airdrop gain, $\hat{Q}_t^q=1000$ denotes the amount of LQTY token airdropped to the stability pool providers
- $D_{t}^{s}$ is the total amount of LUSD deposited in the Stability Pool (see below)

# Exogenous Factors

Ether Price
"""

#ether price
for i in range(1, period):
  random.seed(2019375+10000*i)
  shock_ether = random.normalvariate(0, sd_ether)
  price_ether.append(price_ether[i-1] * (1 + shock_ether) * (1 + drift_ether))

"""Natural Rate"""

#natural rate
for i in range(1, period):
  random.seed(201597+10*i)
  shock_natural = random.normalvariate(0,sd_natural_rate)
  natural_rate.append(natural_rate[i-1]*(1+shock_natural))


"""# Troves

Liquidate Troves
"""

def is_recovery_mode(contracts, price_ether_current):
    price = Wei(price_ether_current * 1e18)
    return contracts.troveManager.checkRecoveryMode(price)

def pending_liquidations(contracts, price_ether_current):
    last_trove = contracts.sortedTroves.getLast()
    last_ICR = contracts.troveManager.getCurrentICR(last_trove, Wei(price_ether_current * 1e18))

    if last_trove == ZERO_ADDRESS:
        return False
    if last_ICR >= Wei(15e17):
        return False
    if last_ICR < Wei(11e17):
        return True
    if not is_recovery_mode(contracts, price_ether_current):
        return False

    stability_pool_balance = contracts.stabilityPool.getTotalLUSDDeposits()
    trove = last_trove
    for i in range(NUM_LIQUIDATIONS):
        debt = contracts.troveManager.getEntireDebtAndColl(trove)[0]
        if stability_pool_balance >= debt:
            return True
        trove = contracts.sortedTroves.getPrev(trove)

    return False

def remove_account(accounts, active_accounts, inactive_accounts, address):
    try:
        active_index = next(i for i, a in enumerate(active_accounts) if accounts[a['index']] == address)
        inactive_accounts.append(active_accounts[active_index]['index'])
        active_accounts.pop(active_index)
    except StopIteration: # TODO
        print(f"\n ***Error: {address} not found in active accounts!")

def remove_accounts_from_events(accounts, active_accounts, inactive_accounts, events, field):
    for event in events:
        remove_account(accounts, active_accounts, inactive_accounts, event[field])

def liquidate_troves(accounts, contracts, active_accounts, inactive_accounts, price_ether_current, price_LUSD, data, index):
    if len(active_accounts) == 0:
        return [0, 0]

    stability_pool_previous = contracts.stabilityPool.getTotalLUSDDeposits() / 1e18
    stability_pool_eth_previous = contracts.stabilityPool.getETH() / 1e18

    while pending_liquidations(contracts, price_ether_current):
        tx = contracts.troveManager.liquidateTroves(NUM_LIQUIDATIONS, { 'from': accounts[0] })
        #print(tx.events['TroveLiquidated'])
        remove_accounts_from_events(accounts, active_accounts, inactive_accounts, tx.events['TroveLiquidated'], '_borrower')

    stability_pool_current = contracts.stabilityPool.getTotalLUSDDeposits() / 1e18
    stability_pool_eth_current = contracts.stabilityPool.getETH() / 1e18

    debt_liquidated = stability_pool_current - stability_pool_previous
    ether_liquidated = stability_pool_eth_current - stability_pool_eth_previous
    liquidation_gain = ether_liquidated * price_ether_current - debt_liquidated * price_LUSD
    #airdrop_gain = price_LQTY_previous * quantity_LQTY_airdrop

    data['liquidation_gain'][index] = liquidation_gain
    data['airdrop_gain'][index] = 0 # TODO!

    return_stability = calculate_stability_return(contracts, price_LUSD, data, index)

    return [ether_liquidated, return_stability]

def calculate_stability_return(contracts, price_LUSD, data, index):
    stability_pool_previous = contracts.stabilityPool.getTotalLUSDDeposits() / 1e18
    if index == 0:
        return_stability = initial_return
    if stability_pool_previous == 0:
        return_stability = 0
    elif index < month:
        return_stability = (year/index) * \
            (sum(data['liquidation_gain'][0:index]) +
             sum(data['airdrop_gain'][0:index])
             ) / (price_LUSD * stability_pool_previous)
    else:
        return_stability = (year/month) * \
            (sum(data['liquidation_gain'][index - month:index]) +
             sum(data['airdrop_gain'][index - month:index])
             ) / (price_LUSD * stability_pool_previous)

    return return_stability

"""Close Troves"""

def close_troves(accounts, contracts, active_accounts, inactive_accounts, price_ether_current, price_LUSD, index):
    if len(active_accounts) == 0:
        return [0]

    if is_recovery_mode(contracts, price_ether_current):
        return [0]

    np.random.seed(208+index)
    shock_closetroves = np.random.normal(0,sd_closetroves)
    n_troves = contracts.sortedTroves.getSize()

    if index <= 240:
        number_closetroves = np.random.uniform(0,1)
    elif price_LUSD >=1:
        number_closetroves = max(0, n_steady * (1+shock_closetroves))
    else:
        number_closetroves = max(0, n_steady * (1+shock_closetroves)) + beta*(1-price_LUSD)*n_troves

    number_closetroves = min(int(round(number_closetroves)), len(active_accounts) - 1)
    random.seed(293+100*index)
    drops = list(random.sample(range(len(active_accounts)), number_closetroves))
    for i in range(0, len(drops)):
        account_index = active_accounts[drops[i]]['index']
        account = accounts[account_index]
        pending = get_lusd_to_repay(accounts, contracts, active_accounts, inactive_accounts, account, get_total_debt(contracts, account))
        if pending == 0:
            # TODO: try to predict it!
            try: # to skip “BorrowerOps: An operation that would result in TCR < CCR is not permitted” errors
                contracts.borrowerOperations.closeTrove({ 'from': account })
                inactive_accounts.append(account_index)
                active_accounts.pop(drops[i])
            except:
                print("\n ***Error closing Trove!")
        if is_recovery_mode(contracts, price_ether_current):
          break

    return [number_closetroves]

"""Adjust Troves"""

def get_total_coll(contracts, account):
    amounts = contracts.troveManager.getEntireDebtAndColl(account)
    return amounts['coll']

def get_total_debt(contracts, account):
    amounts = contracts.troveManager.getEntireDebtAndColl(account)
    return amounts['debt']

def transfer_from_to(contracts, from_account, to_account, amount):
    balance = contracts.lusdToken.balanceOf(from_account)
    transfer_amount = min(balance, amount)
    if transfer_amount == 0:
        return amount
    if from_account == to_account:
        return amount
    contracts.lusdToken.transfer(to_account, transfer_amount, { 'from': from_account })
    pending = amount - transfer_amount

    return pending

def get_lusd_to_repay(accounts, contracts, active_accounts, inactive_accounts, account, debt):
    lusdBalance = contracts.lusdToken.balanceOf(account)
    if debt > lusdBalance:
        pending = debt - lusdBalance
        # first try with whale
        pending = transfer_from_to(contracts, accounts[0], account, pending)
        # first try with active accounts, which are more likely to hold LUSD
        for a in active_accounts:
            if pending <= 0:
                break
            a_address = accounts[a['index']]
            pending = transfer_from_to(contracts, a_address, account, pending)
        for i in inactive_accounts:
            if pending <= 0:
                break
            i_address = accounts[i]
            pending = transfer_from_to(contracts, i_address, account, pending)

        if pending > 0:
            print(f"\n ***Error: not enough LUSD to repay! {debt / 1e18} LUSD for {account}")

        return pending

    return 0

def get_hints(contracts, coll, debt):
    NICR = contracts.hintHelpers.computeNominalCR(floatToWei(coll), floatToWei(debt))
    approxHint = contracts.hintHelpers.getApproxHint(NICR, 100, 0)
    #print("approx hint", approxHint)
    return contracts.sortedTroves.findInsertPosition(NICR, approxHint[0], approxHint[0])

def get_hints_from_amounts(accounts, contracts, active_accounts, coll, debt, price_ether_current):
    ICR = coll * price_ether_current / debt
    NICR = contracts.hintHelpers.computeNominalCR(floatToWei(coll), floatToWei(debt))
    return get_hints_from_ICR(accounts, contracts, active_accounts, ICR, NICR)

#def get_address_from_active_index(accounts, active_accounts, index):
def index2address(accounts, active_accounts, index):
    return accounts[active_accounts[index]['index']]

def get_hints_from_ICR(accounts, contracts, active_accounts, ICR, NICR):
    l = len(active_accounts)
    if l == 0:
        return [ZERO_ADDRESS, ZERO_ADDRESS, 0]
    else:
        keys = [a['CR_initial'] for a in active_accounts]
        i = bisect_left(keys, ICR)
        #return [index2address(accounts, active_accounts, min(i, l-1)), index2address(accounts, active_accounts, max(i-1, 0)), i]
        hints = contracts.sortedTroves.findInsertPosition(
            NICR,
            index2address(accounts, active_accounts, min(i, l-1)),
            index2address(accounts, active_accounts, max(i-1, 0))
        )
        return [hints[0], hints[1], i]


def adjust_troves(accounts, contracts, active_accounts, inactive_accounts, price_ether_current, index):
    random.seed(57984-3*index)
    ratio = random.uniform(0,1)
    coll_added_float = 0

    for i, working_trove in enumerate(active_accounts):
        account = accounts[working_trove['index']]
        currentICR = contracts.troveManager.getCurrentICR(account, floatToWei(price_ether_current)) / 1e18
        coll = get_total_coll(contracts, account) / 1e18
        debt = get_total_debt(contracts, account) / 1e18

        random.seed(187*index + 3*i)
        p = random.uniform(0,1)
        check = (currentICR - working_trove['CR_initial']) / (working_trove['CR_initial'] * working_trove['Rational_inattention'])

        if check >= -1 and check <= 2:
            continue

        #A part of the troves are adjusted by adjusting debt
        if p >= ratio:
            debt_new = price_ether_current * coll / working_trove['CR_initial']
            hints = get_hints_from_amounts(accounts, contracts, active_accounts, coll, debt_new, price_ether_current)
            if debt_new < MIN_NET_DEBT:
                continue
            if check < -1:
                # pay back
                repay_amount = floatToWei(debt - debt_new)
                pending = get_lusd_to_repay(accounts, contracts, active_accounts, inactive_accounts, account, repay_amount)
                if pending == 0:
                    contracts.borrowerOperations.repayLUSD(repay_amount, hints[0], hints[1], { 'from': account })
            elif check > 2 and not is_recovery_mode(contracts, price_ether_current):
                # withdraw LUSD
                withdraw_amount = floatToWei(debt_new - debt)
                try: # to skip “BorrowerOps: An operation that would result in TCR < CCR is not permitted” errors
                    contracts.borrowerOperations.withdrawLUSD(MAX_FEE, withdraw_amount, hints[0], hints[1], { 'from': account })
                except:
                    print("\n ***Error withdrawing LUSD!")
        #Another part of the troves are adjusted by adjusting collaterals
        elif p < ratio:
            coll_new = working_trove['CR_initial'] * debt / price_ether_current
            hints = get_hints_from_amounts(accounts, contracts, active_accounts, coll_new, debt, price_ether_current)
            if check < -1:
                # add coll
                coll_added_float = coll_new - coll
                coll_added = floatToWei(coll_added_float)
                contracts.borrowerOperations.addColl(hints[0], hints[1], { 'from': account, 'value': coll_added })
            elif check > 2 and not is_recovery_mode(contracts, price_ether_current):
                # withdraw ETH
                coll_withdrawn = floatToWei(coll - coll_new)
                try: # to skip “BorrowerOps: An operation that would result in TCR < CCR is not permitted” errors
                    contracts.borrowerOperations.withdrawColl(coll_withdrawn, hints[0], hints[1], { 'from': account })
                except:
                    print("\n ***Error withdrawing ETH!")

    return coll_added_float

"""Open Troves"""

def open_trove(accounts, contracts, active_accounts, inactive_accounts, supply_trove, quantity_ether, CR_ratio, rational_inattention, price_ether_current):
    if len(inactive_accounts) == 0:
        return
    if is_recovery_mode(contracts, price_ether_current) and CR_ratio < 1.5:
        return

    #hints = get_hints_from_ICR(accounts, active_accounts, CR_ratio)
    hints = get_hints_from_amounts(accounts, contracts, active_accounts, quantity_ether, supply_trove, price_ether_current)
    try: # to skip “BorrowerOps: An operation that would result in TCR < CCR is not permitted” errors
        contracts.borrowerOperations.openTrove(MAX_FEE, floatToWei(supply_trove), hints[0], hints[1],
                                               { 'from': accounts[inactive_accounts[0]], 'value': floatToWei(quantity_ether) })
        new_account = {"index": inactive_accounts[0], "CR_initial": CR_ratio, "Rational_inattention": rational_inattention}
        active_accounts.insert(hints[2], new_account)
        inactive_accounts.pop(0)
    except:
        print("\n ***Error opening trove!")
        print(f"Coll: {quantity_ether}")
        print(f"Debt: {supply_trove}")
        print(f"Hint: {hints[0]}")
        print(f"Hint: {hints[1]}")
        print(f"From: {accounts[inactive_accounts[0]]}")
        print(f"Index {inactive_accounts[0]}")
        print(f"ICR:  {CR_ratio}")
        print(f"inatt {rational_inattention}")
        print(f"$/ETH {price_ether_current}")
        print(f"H ICR {contracts.troveManager.getCurrentICR(hints[0], Wei(price_ether_current * 1e18))}")
        print(f"H ICR {contracts.troveManager.getCurrentICR(hints[1], Wei(price_ether_current * 1e18))}")

def open_troves(accounts, contracts, active_accounts, inactive_accounts, price_ether_current, price_LUSD, index):
    random.seed(2019*index)
    shock_opentroves = random.normalvariate(0,sd_opentroves)
    n_troves = len(active_accounts)
    rate_issuance = contracts.troveManager.getBorrowingRateWithDecay() / 1e18
    coll_added = 0

    if index <= 0:
        number_opentroves = initial_open
    elif price_LUSD <= 1 + rate_issuance:
        number_opentroves = max(0, n_steady * (1+shock_opentroves))
    else:
        number_opentroves = max(0, n_steady * (1+shock_opentroves)) + \
                        alpha * (price_LUSD - rate_issuance - 1) * n_troves

    number_opentroves = min(int(round(float(number_opentroves))), len(inactive_accounts))

    for i in range(0, number_opentroves):
        np.random.seed(2033 + index + i*i)
        CR_ratio = target_cr_a + target_cr_b * np.random.chisquare(df=target_cr_chi_square_df)

        np.random.seed(20 + 10 * i + index)
        quantity_ether = np.random.gamma(collateral_gamma_k, scale=collateral_gamma_theta)

        np.random.seed(209870- index + i*i)
        rational_inattention = np.random.gamma(rational_inattention_gamma_k, scale=rational_inattention_gamma_theta)
        supply_trove = price_ether_current * quantity_ether / CR_ratio
        if supply_trove < MIN_NET_DEBT:
            supply_trove = MIN_NET_DEBT
            quantity_ether = CR_ratio * supply_trove / price_ether_current

        open_trove(accounts, contracts, active_accounts, inactive_accounts, supply_trove, quantity_ether, CR_ratio, rational_inattention, price_ether_current)

        coll_added = coll_added + quantity_ether

    return coll_added


"""# LUSD Market

Stability Pool
"""

def stability_update(accounts, contracts, return_stability, index):
    supply = contracts.lusdToken.totalSupply() / 1e18
    stability_pool_previous = contracts.stabilityPool.getTotalLUSDDeposits() / 1e18

    np.random.seed(27+3*index)
    shock_stability = np.random.normal(0,sd_stability)
    natural_rate_current = natural_rate[index]
    if index <= month:
        stability_pool = stability_pool_previous * drift_stability * (1+shock_stability) * (1 + return_stability - natural_rate_current)**theta
    else:
        stability_pool = stability_pool_previous * (1+shock_stability) * (1 + return_stability - natural_rate_current)**theta

        if stability_pool > supply:
            print("Warning! Stability pool supposed to be greater than supply", stability_pool, supply)
            stability_pool = supply

        if stability_pool > stability_pool_previous:

            whale_balance = contracts.lusdToken.balanceOf(accounts[0]) / 1e18
            new_deposit = stability_pool - stability_pool_previous
            if new_deposit > whale_balance:
                print("Warning! Stability pool supposed to be greater than whale balance", new_deposit, whale_balance)
            else:
                contracts.stabilityPool.provideToSP(floatToWei(new_deposit), ZERO_ADDRESS, { 'from': accounts[0] })
        else:
            current_deposit = contracts.stabilityPool.getCompoundedLUSDDeposit(accounts[0])
            if current_deposit > 0:
                new_withdraw = min(floatToWei(stability_pool_previous - stability_pool), current_deposit)
                contracts.stabilityPool.withdrawFromSP(new_withdraw, { 'from': accounts[0] })


"""LUSD Price, liquidity pool, and redemption

**Price Determination**

---
With the supply and demand of LUSD tokens defined above, the price of LUSD at the current period is given by the following equilibrium condition:
> $$S_t = D_t^s + D_t^l = D_t^s + D_{t-1}^l (1+\zeta_t^l)(1+\sigma_t^l) (\frac{P_t^l}{P_{t-1}^l})^\delta$$

where $S$ is the total supply of LUSD.

Solving this equation gives that:
> $$P_t^l = P_{t-1}^l (\frac{S_t-D_t^s}{D_{t-1}^l(1+\zeta_t^l)(1+\sigma_t^l)})^{1/\delta}$$
"""

def calculate_price(price_LUSD, liquidity_pool, liquidity_pool_next):
  # liquidity_pool = supply - stability_pool
  # liquidity_pool_next = liquidity_pool_previous * drift_liquidity * (1+shock_liquidity)
  price_LUSD_current= price_LUSD * (liquidity_pool / liquidity_pool_next) ** (1/delta)

  return price_LUSD_current

""" **Stabilizers**

There are two stabilizers to attenuate LUSD price deviation from its target range.
No action if $P_t^l \in [1-f_t^r, 1.1+f_t^i]$, where $f_t^r$ represents the redemption fee, and $f_t^i$ represents the issuance fee.
For the moment, we set $f_t^r = 1\%$.


---
Stabilizer 1: ceiling arbitrageurs

If $P_t^l > 1.1+f_t^i$, open a new trove with $CR^*=110\%$ and $\tau^*=10\%$. Its debt amounts to
> $$Q_t^d(c) = \frac{P_t^e Q_t^e(c)}{110\%}.$$

The amount of $Q_t^d(c)$ is expected to bring the LUSD price back to $1.1+f_t^i$. This means that
> $$S_t' = D_t^s + (\frac{1.1+f_t^i}{P_{t-1}^l})^\delta D_{t-1}^l(1+\zeta_t^l)(1+\sigma_t^l)$$

The debt of th new trove is the difference between the original supply and the supply needed to bring price to $1.1+f_t^i$, which is
> $$Q_t^d(c) = S_t' - S_t$$

**Programming logic**:

market clearing condition supply = demand ==> $P_t^l$ is determined

If $P_t^l > 1.1+f_t^i$ ==> calculate what amount of extra supply leads to
$P_t^l = 1.1+f_t^i$ ==> denote this amount by $Q_t^d(c)$ ==> open a trove
with $CR^*=110\%$ and debt = $Q_t^d(c)$

---
Stabilizer 2: floor arbitrageurs

If $P_t^l < 1-f_t^r$, a fraction $\chi_t$ of LUSD in the liquidity pool is used for redemption
> $$D_t^r = \chi_t D_t^l,$$

where
> $$\chi_t = ...$$

The redemption eliminates troves with the lowest collateral ratio.

Note that unlike stabilizer 1, stabilizer 2 has impact of LUSD price in
 the next period. Namely, after the determination of $P_t^l$ and if $P_t^l < 1-f_t^r$, the redemption does not affect $P_t^l$ any more. So no need to
program stabilizer 2 like what you did for stabilizer 1. The redemption kills some troves and thus affect $P_{t+1}^l$ in the next period as the number of troves shrinks.

**Programming logic**

Denote the amount of troves fully redeemed by $N_t^r$. Therefore,
> $$D_t^r = \sum_i^{N_t^r} Q_t^d(i) + \Delta$$

where $\Delta \geq 0$ represents the residual.

Note that the redemption starts from the riskest troves, i.e. those with
the lowest collateral ratios.

If any residual $\Delta > 0$ left, then the changes to the trove $j$ with the lowest collateral ratio are
> $$Q_{t+1}^e(j) = Q_{t}^e(j) - \Delta/P_t^e$$
> $$Q_{t+1}^d(j) = Q_{t}^d(j) - \Delta$$
> $$CR_{t+1}(j) = \frac{P_t^e(Q_{t}^e(j) - \Delta)}{Q_{t}^d(j) - \Delta}$$
---


Redemption fee revenue amounts to

> $$R_t^r = D_t^r(f_t^r + \frac{D_t^r}{S_t^l})$$
"""

# redemption pool - to avoid redempting the whole liquidity pool
sd_redemption = 0.001
redemption_start = 0.8

def price_stabilizer(accounts, contracts, active_accounts, price_LUSD, index):

    stability_pool = contracts.stabilityPool.getTotalLUSDDeposits() / 1e18
    redemption_pool = 0

    supply = contracts.lusdToken.totalSupply() / 1e18
    #Liquidity Pool
    liquidity_pool = supply - stability_pool

    # next iteration step for liquidity pool
    np.random.seed(20*index)
    shock_liquidity = np.random.normal(0,sd_liquidity)

    liquidity_pool_next = liquidity_pool * drift_liquidity * (1+shock_liquidity)

    #Calculating Price
    price_LUSD_current = calculate_price(price_LUSD, liquidity_pool, liquidity_pool_next)
    rate_issuance = contracts.troveManager.getBorrowingRateWithDecay() / 1e18
    rate_redemption = contracts.troveManager.getRedemptionRateWithDecay() / 1e18

    #Stabilizer
    #Ceiling Arbitrageurs
    if price_LUSD_current > 1.1 + rate_issuance:
        supply_wanted = stability_pool + \
                        liquidity_pool_next * \
                        ((1.1+rate_issuance) / price_LUSD)**delta
        supply_trove = min(supply_wanted - supply, MIN_NET_DEBT)

        CR_ratio = 1.1
        rational_inattention = 0.1
        quantity_ether = supply_trove * CR_ratio / price_ether_current
        open_trove(accounts, contracts, active_accounts, inactive_accounts, supply_trove, quantity_ether, CR_ratio, rational_inattention)
        price_LUSD_current = 1.1 + rate_issuance
        #missing in the previous version
        liquidity_pool = supply_wanted - stability_pool


    #Floor Arbitrageurs
    if price_LUSD_current < 1 - rate_redemption:
        np.random.seed(30*index)
        shock_redemption = np.random.normal(0, sd_redemption)
        redemption_ratio = max(1, redemption_start * (1+shock_redemption))

        supply_target = stability_pool + \
                        liquidity_pool_next * \
                        ((1-rate_redemption) / price_LUSD)**delta
        supply_diff = supply - supply_target
        if supply_diff < redemption_ratio * liquidity_pool:
            redemption_pool = supply_diff
            #liquidity_pool = liquidity_pool - redemption_pool
            price_LUSD_current = 1 - rate_redemption
        else:
            redemption_pool = redemption_ratio * liquidity_pool
            #liquidity_pool = (1-redemption_ratio)*liquidity_pool
            price_LUSD_current = calculate_price(price_LUSD, liquidity_pool, liquidity_pool_next)

        whale_balance = contracts.lusdToken.balanceOf(accounts[0]) / 1e18
        new_deposit = stability_pool - stability_pool_previous
        if redemption_pool > whale_balance:
            print("Warning! Redemption amount supposed to be greater than whale balance", stability_pool, whale_balance)
        else:
            tx = contracts.troveManager.redeemCollateral(floatToWei(redemption_pool), { 'from': accounts[0] })
            remove_accounts_from_events(
                accounts,
                active_accounts,
                inactive_accounts,
                filter(lambda e: e['coll'] == 0, tx.events['TroveUpdated']),
                '_borrower'
            )


    return [price_LUSD_current, redemption_pool]
